// Code generated by gendb; DO NOT EDIT.
package model

import (
	"context"
	"database/sql"
	"fmt"
	"strings"
	"time"

	"github.com/jmoiron/sqlx"
)

const (
	UserOpenIdMapTable = "user_open_id_map"
)

type userOpenIdMapColumn struct {
	Id        string
	UserId    string
	OpenId    string
	OutOpenId string
	AppId     string
	Extra     string
	SysCtime  string
	SysUtime  string
	IsDel     string
}

var (
	UserOpenIdMapCol = &userOpenIdMapColumn{
		Id:        "id",
		UserId:    "user_id",
		OpenId:    "open_id",
		OutOpenId: "out_open_id",
		AppId:     "app_id",
		Extra:     "extra",
		SysCtime:  "sys_ctime",
		SysUtime:  "sys_utime",
		IsDel:     "is_del",
	}
)

type UserOpenIdMapEntity struct {
	Id        int64     `db:"id"`
	UserId    string    `db:"user_id"`
	OpenId    string    `db:"open_id"`
	OutOpenId string    `db:"out_open_id"`
	AppId     string    `db:"app_id"`
	Extra     *string   `db:"extra"`
	SysCtime  time.Time `db:"sys_ctime"`
	SysUtime  time.Time `db:"sys_utime"`
	IsDel     int       `db:"is_del"`
}

type UserOpenIdMapModel interface {
	Insert(context.Context, ...map[string]interface{}) (sql.Result, error)
	Select(context.Context, map[string]interface{}, ...string) ([]*UserOpenIdMapEntity, error)
}

var (
	u *userOpenIdMapImpl
)

type userOpenIdMapImpl struct {
	db sqlx.ExtContext
}

func SetUserOpenIdMapCli(db sqlx.ExtContext) {
	u = &userOpenIdMapImpl{db: db}
}

func GetUserOpenIdMapCli() UserOpenIdMapModel {
	return u
}

var _ UserOpenIdMapModel = (*userOpenIdMapImpl)(nil)

func (u *userOpenIdMapImpl) Insert(ctx context.Context, values ...map[string]interface{}) (sql.Result, error) {
	if len(values) == 0 {
		return nil, nil
	}
	var fields []string
	for k := range values[0] {
		fields = append(fields, k)
	}
	k := strings.Join(fields, ",")
	v := ":" + strings.Join(fields, ",:")
	s := fmt.Sprintf("INSERT INTO user_open_id_map (%s) VALUES (%s);", k, v)
	result, err := sqlx.NamedExecContext(ctx, u.db, s, values)
	if err != nil {
		return nil, fmt.Errorf("insert error %w", err)
	}
	return result, nil
}

func (u *userOpenIdMapImpl) Select(ctx context.Context, values map[string]interface{}, fields ...string) ([]*UserOpenIdMapEntity, error) {
	var result []*UserOpenIdMapEntity

	var s []string
	var args []interface{}
	for k, v := range values {
		s = append(s, fmt.Sprintf("%s=?", k))
		args = append(args, v)
	}
	var query = fmt.Sprintf("SELECT %s FROM user_open_id_map WHERE %s", strings.Join(fields, ","), strings.Join(s, " and "))
	err := sqlx.SelectContext(ctx, u.db, &result, query, args...)
	if err != nil {
		return nil, fmt.Errorf("select error %w", err)
	}
	return result, nil
}
