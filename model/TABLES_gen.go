// Code generated by gendb; DO NOT EDIT.
package model

import (
	"context"
	"database/sql"
	"fmt"
	"strings"
	"time"

	"github.com/jmoiron/sqlx"
)

const (
	TABLESTableName = "TABLES"
)

type tABLESColumn struct {
	AUTOINCREMENT  string
	AVGROWLENGTH   string
	CHECKTIME      string
	CHECKSUM       string
	CREATEOPTIONS  string
	CREATETIME     string
	DATAFREE       string
	DATALENGTH     string
	ENGINE         string
	INDEXLENGTH    string
	MAXDATALENGTH  string
	ROWFORMAT      string
	TABLECATALOG   string
	TABLECOLLATION string
	TABLECOMMENT   string
	TABLENAME      string
	TABLEROWS      string
	TABLESCHEMA    string
	TABLETYPE      string
	UPDATETIME     string
	VERSION        string
}

var (
	TABLESCol = &tABLESColumn{
		AUTOINCREMENT:  "AUTO_INCREMENT",
		AVGROWLENGTH:   "AVG_ROW_LENGTH",
		CHECKTIME:      "CHECK_TIME",
		CHECKSUM:       "CHECKSUM",
		CREATEOPTIONS:  "CREATE_OPTIONS",
		CREATETIME:     "CREATE_TIME",
		DATAFREE:       "DATA_FREE",
		DATALENGTH:     "DATA_LENGTH",
		ENGINE:         "ENGINE",
		INDEXLENGTH:    "INDEX_LENGTH",
		MAXDATALENGTH:  "MAX_DATA_LENGTH",
		ROWFORMAT:      "ROW_FORMAT",
		TABLECATALOG:   "TABLE_CATALOG",
		TABLECOLLATION: "TABLE_COLLATION",
		TABLECOMMENT:   "TABLE_COMMENT",
		TABLENAME:      "TABLE_NAME",
		TABLEROWS:      "TABLE_ROWS",
		TABLESCHEMA:    "TABLE_SCHEMA",
		TABLETYPE:      "TABLE_TYPE",
		UPDATETIME:     "UPDATE_TIME",
		VERSION:        "VERSION",
	}
)

type TABLESEntity struct {
	AUTOINCREMENT  *int64     `db:"AUTO_INCREMENT"`
	AVGROWLENGTH   *int64     `db:"AVG_ROW_LENGTH"`
	CHECKTIME      *time.Time `db:"CHECK_TIME"`
	CHECKSUM       *int64     `db:"CHECKSUM"`
	CREATEOPTIONS  *string    `db:"CREATE_OPTIONS"`
	CREATETIME     time.Time  `db:"CREATE_TIME"`
	DATAFREE       *int64     `db:"DATA_FREE"`
	DATALENGTH     *int64     `db:"DATA_LENGTH"`
	ENGINE         *string    `db:"ENGINE"`
	INDEXLENGTH    *int64     `db:"INDEX_LENGTH"`
	MAXDATALENGTH  *int64     `db:"MAX_DATA_LENGTH"`
	ROWFORMAT      *string    `db:"ROW_FORMAT"`
	TABLECATALOG   string     `db:"TABLE_CATALOG"`
	TABLECOLLATION *string    `db:"TABLE_COLLATION"`
	TABLECOMMENT   *string    `db:"TABLE_COMMENT"`
	TABLENAME      string     `db:"TABLE_NAME"`
	TABLEROWS      *int64     `db:"TABLE_ROWS"`
	TABLESCHEMA    string     `db:"TABLE_SCHEMA"`
	TABLETYPE      string     `db:"TABLE_TYPE"`
	UPDATETIME     *time.Time `db:"UPDATE_TIME"`
	VERSION        *int       `db:"VERSION"`
}

type TABLESModel interface {
	Insert(context.Context, ...map[string]interface{}) (sql.Result, error)
	Select(context.Context, map[string]interface{}, ...string) ([]*TABLESEntity, error)
}

var (
	t *tABLESImpl
)

type tABLESImpl struct {
	db sqlx.ExtContext
}

func SetTABLESCli(db sqlx.ExtContext) {
	t = &tABLESImpl{db: db}
}

func GetTABLESCli() TABLESModel {
	return t
}

var _ TABLESModel = (*tABLESImpl)(nil)

func (t *tABLESImpl) Insert(ctx context.Context, values ...map[string]interface{}) (sql.Result, error) {
	if len(values) == 0 {
		return nil, nil
	}
	var fields []string
	for k := range values[0] {
		fields = append(fields, k)
	}
	k := strings.Join(fields, ",")
	v := ":" + strings.Join(fields, ",:")
	s := fmt.Sprintf("INSERT INTO TABLES (%s) VALUES (%s);", k, v)
	result, err := sqlx.NamedExecContext(ctx, t.db, s, values)
	if err != nil {
		return nil, fmt.Errorf("insert error %w", err)
	}
	return result, nil
}

func (t *tABLESImpl) Select(ctx context.Context, values map[string]interface{}, fields ...string) ([]*TABLESEntity, error) {
	var result []*TABLESEntity

	var s []string
	var args []interface{}
	for k, v := range values {
		s = append(s, fmt.Sprintf("%s=?", k))
		args = append(args, v)
	}
	var query = fmt.Sprintf("SELECT %s FROM TABLES WHERE %s", strings.Join(fields, ","), strings.Join(s, " and "))
	err := sqlx.SelectContext(ctx, t.db, &result, query, args...)
	if err != nil {
		return nil, fmt.Errorf("select error %w", err)
	}
	return result, nil
}
