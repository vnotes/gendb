// Code generated by gendb; DO NOT EDIT.

package tablesapi

import (
	"context"
	"database/sql"
	"fmt"
	"strings"
	"time"

	"github.com/jmoiron/sqlx"
)

const TableName = "TABLES"

type column struct {
	AUTOINCREMENT  string
	AVGROWLENGTH   string
	CHECKTIME      string
	CHECKSUM       string
	CREATEOPTIONS  string
	CREATETIME     string
	DATAFREE       string
	DATALENGTH     string
	ENGINE         string
	INDEXLENGTH    string
	MAXDATALENGTH  string
	ROWFORMAT      string
	TABLECATALOG   string
	TABLECOLLATION string
	TABLECOMMENT   string
	TABLENAME      string
	TABLEROWS      string
	TABLESCHEMA    string
	TABLETYPE      string
	UPDATETIME     string
	VERSION        string
}

var (
	Col = &column{
		AUTOINCREMENT:  "AUTO_INCREMENT",
		AVGROWLENGTH:   "AVG_ROW_LENGTH",
		CHECKTIME:      "CHECK_TIME",
		CHECKSUM:       "CHECKSUM",
		CREATEOPTIONS:  "CREATE_OPTIONS",
		CREATETIME:     "CREATE_TIME",
		DATAFREE:       "DATA_FREE",
		DATALENGTH:     "DATA_LENGTH",
		ENGINE:         "ENGINE",
		INDEXLENGTH:    "INDEX_LENGTH",
		MAXDATALENGTH:  "MAX_DATA_LENGTH",
		ROWFORMAT:      "ROW_FORMAT",
		TABLECATALOG:   "TABLE_CATALOG",
		TABLECOLLATION: "TABLE_COLLATION",
		TABLECOMMENT:   "TABLE_COMMENT",
		TABLENAME:      "TABLE_NAME",
		TABLEROWS:      "TABLE_ROWS",
		TABLESCHEMA:    "TABLE_SCHEMA",
		TABLETYPE:      "TABLE_TYPE",
		UPDATETIME:     "UPDATE_TIME",
		VERSION:        "VERSION",
	}
)

type Entity struct {
	AUTOINCREMENT  *int64     `db:"AUTO_INCREMENT"`
	AVGROWLENGTH   *int64     `db:"AVG_ROW_LENGTH"`
	CHECKTIME      *time.Time `db:"CHECK_TIME"`
	CHECKSUM       *int64     `db:"CHECKSUM"`
	CREATEOPTIONS  *string    `db:"CREATE_OPTIONS"`
	CREATETIME     time.Time  `db:"CREATE_TIME"`
	DATAFREE       *int64     `db:"DATA_FREE"`
	DATALENGTH     *int64     `db:"DATA_LENGTH"`
	ENGINE         *string    `db:"ENGINE"`
	INDEXLENGTH    *int64     `db:"INDEX_LENGTH"`
	MAXDATALENGTH  *int64     `db:"MAX_DATA_LENGTH"`
	ROWFORMAT      *string    `db:"ROW_FORMAT"`
	TABLECATALOG   string     `db:"TABLE_CATALOG"`
	TABLECOLLATION *string    `db:"TABLE_COLLATION"`
	TABLECOMMENT   *string    `db:"TABLE_COMMENT"`
	TABLENAME      string     `db:"TABLE_NAME"`
	TABLEROWS      *int64     `db:"TABLE_ROWS"`
	TABLESCHEMA    string     `db:"TABLE_SCHEMA"`
	TABLETYPE      string     `db:"TABLE_TYPE"`
	UPDATETIME     *time.Time `db:"UPDATE_TIME"`
	VERSION        *int       `db:"VERSION"`
}

type model interface {
	dbInsert(context.Context, ...map[string]interface{}) (sql.Result, error)
	dbSelect(context.Context, map[string]interface{}, ...string) ([]*Entity, error)
}

type impl struct {
	db sqlx.ExtContext
}

var i *impl

func SetCli(db sqlx.ExtContext) {
	i = &impl{db: db}
}

func GetCli() model {
	return i
}

var _ model = (*impl)(nil)

func (i *impl) dbInsert(ctx context.Context, values ...map[string]interface{}) (sql.Result, error) {
	if len(values) == 0 {
		return nil, nil
	}
	var fields []string
	for k := range values[0] {
		fields = append(fields, k)
	}
	k := strings.Join(fields, ",")
	v := ":" + strings.Join(fields, ",:")
	s := fmt.Sprintf("INSERT INTO TABLES (%s) VALUES (%s);", k, v)
	result, err := sqlx.NamedExecContext(ctx, i.db, s, values)
	if err != nil {
		return nil, fmt.Errorf("insert error %w", err)
	}
	return result, nil
}

func (i *impl) dbSelect(ctx context.Context, values map[string]interface{}, fields ...string) ([]*Entity, error) {
	var result []*Entity

	var s []string
	var args []interface{}
	for k, v := range values {
		s = append(s, fmt.Sprintf("%s=?", k))
		args = append(args, v)
	}
	var query = fmt.Sprintf("SELECT %s FROM TABLES WHERE %s", strings.Join(fields, ","), strings.Join(s, " and "))
	err := sqlx.SelectContext(ctx, i.db, &result, query, args...)
	if err != nil {
		return nil, fmt.Errorf("select error %w", err)
	}
	return result, nil
}
